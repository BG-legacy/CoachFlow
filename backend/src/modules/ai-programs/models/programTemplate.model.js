/**
 * Program Template Model
 * Stores AI-generated programs as reusable, versioned templates/artifacts
 */

const mongoose = require('mongoose');
const crypto = require('crypto');

const programTemplateSchema = new mongoose.Schema(
  {
    // Template identification (auto-generated by hooks)
    templateId: {
      type: String,
      unique: true,
      index: true,
    },
    name: {
      type: String,
      required: true,
      trim: true,
    },
    description: String,
    
    // Versioning
    version: {
      type: Number,
      default: 1,
      min: 1,
    },
    isLatestVersion: {
      type: Boolean,
      default: true,
      index: true,
    },
    parentTemplateId: {
      type: String, // References another template's templateId
      index: true,
    },
    versionHistory: [{
      version: Number,
      templateId: String,
      createdAt: Date,
      changes: String,
      createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
      },
    }],
    
    // Ownership and access
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    organizationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Organization',
      index: true,
    },
    
    // Template type and categorization
    templateType: {
      type: String,
      enum: ['workout_program', 'nutrition_plan', 'combined'],
      required: true,
      index: true,
    },
    category: {
      type: String,
      enum: ['strength', 'hypertrophy', 'endurance', 'weight_loss', 'general_fitness', 'sports_specific', 'rehabilitation', 'nutrition'],
      index: true,
    },
    tags: [String],
    
    // Template characteristics (for matching/search)
    characteristics: {
      experienceLevel: {
        type: String,
        enum: ['beginner', 'intermediate', 'advanced', 'elite'],
      },
      goals: [String],
      duration: {
        weeks: Number,
        days: Number,
      },
      equipment: [String],
      targetMuscles: [String],
      dietType: String,
      calorieRange: {
        min: Number,
        max: Number,
      },
    },
    
    // Actual program content (versioned artifact)
    content: {
      workoutProgram: {
        name: String,
        description: String,
        duration: {
          weeks: Number,
          workoutsPerWeek: Number,
        },
        workouts: [mongoose.Schema.Types.Mixed],
        progressionStrategy: String,
        deloadWeeks: [Number],
        reasoning: String,
        // Progression Engine Support
        progressionEngine: {
          // RPE (Rate of Perceived Exertion) targets
          rpeTargets: {
            enabled: {
              type: Boolean,
              default: false,
            },
            weeklyTargets: [{
              week: Number,
              targetRPE: Number, // 1-10 scale
              notes: String,
            }],
            exerciseSpecificTargets: [{
              exerciseId: String,
              targetRPE: Number,
              adjustmentRules: String,
            }],
          },
          // Progression rules
          progressionRules: {
            strategy: {
              type: String,
              enum: ['linear', 'wave', 'double_progression', 'percentage_based', 'autoregulated', 'custom'],
              default: 'linear',
            },
            weightIncrement: {
              type: Number, // in kg or lbs
              default: 2.5,
            },
            repRangeProgression: {
              minReps: Number,
              maxReps: Number,
              incrementWhen: String, // e.g., "Complete all sets at maxReps"
            },
            weeklyLoad: [{
              week: Number,
              loadPercentage: Number, // Percentage of max
              volume: String, // e.g., "high", "medium", "low"
            }],
            conditions: [{
              metric: String, // e.g., "rpe", "completedSets", "formQuality"
              threshold: mongoose.Schema.Types.Mixed,
              action: String, // e.g., "increase_weight", "maintain", "deload"
              value: mongoose.Schema.Types.Mixed,
            }],
            customRules: String, // AI-generated custom progression logic
          },
          // Deload triggers and protocol
          deloadProtocol: {
            enabled: {
              type: Boolean,
              default: true,
            },
            scheduledDeloads: [{
              week: Number,
              type: {
                type: String,
                enum: ['volume_reduction', 'intensity_reduction', 'complete_rest', 'active_recovery'],
              },
              reduction: Number, // Percentage reduction
              notes: String,
            }],
            autoDeloadTriggers: [{
              condition: String, // e.g., "consecutive_failed_workouts", "high_avg_rpe", "poor_recovery"
              threshold: mongoose.Schema.Types.Mixed,
              protocol: {
                type: String,
                enum: ['immediate_deload', 'schedule_next_week', 'reduce_volume', 'reduce_intensity'],
              },
              reductionPercentage: Number,
              notes: String,
            }],
            recoveryIndicators: [{
              metric: String, // e.g., "sleep_quality", "soreness_level", "energy"
              target: String,
              weight: Number, // Importance weight for decision making
            }],
          },
        },
      },
      nutritionPlan: {
        name: String,
        description: String,
        dailyTargets: mongoose.Schema.Types.Mixed,
        meals: [mongoose.Schema.Types.Mixed],
        mealTiming: mongoose.Schema.Types.Mixed,
        supplements: [String],
        hydration: mongoose.Schema.Types.Mixed,
        reasoning: String,
      },
    },
    
    // AI generation metadata (frozen artifact)
    aiMetadata: {
      model: String,
      promptTemplate: String,
      temperature: Number,
      tokensUsed: {
        prompt: Number,
        completion: Number,
        total: Number,
      },
      estimatedCost: Number,
      generatedAt: Date,
      generationInputHash: String, // Hash of input parameters
    },
    
    // Fingerprint for duplicate detection (auto-generated by hooks)
    contentFingerprint: {
      type: String,
      index: true,
    },
    inputFingerprint: {
      type: String,
      index: true,
    },
    
    // Usage and performance tracking
    usage: {
      timesUsed: {
        type: Number,
        default: 0,
      },
      activeClients: {
        type: Number,
        default: 0,
      },
      lastUsed: Date,
      successRate: {
        type: Number,
        default: 100,
        min: 0,
        max: 100,
      },
      averageRating: {
        type: Number,
        min: 0,
        max: 5,
      },
    },
    
    // Ratings and feedback
    ratings: [{
      userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
      },
      rating: {
        type: Number,
        min: 1,
        max: 5,
      },
      feedback: String,
      createdAt: {
        type: Date,
        default: Date.now,
      },
    }],
    
    // Template status
    status: {
      type: String,
      enum: ['draft', 'active', 'archived', 'deprecated'],
      default: 'active',
      index: true,
    },
    
    // Access control
    visibility: {
      type: String,
      enum: ['private', 'organization', 'public'],
      default: 'private',
      index: true,
    },
    isTemplate: {
      type: Boolean,
      default: true,
    },
    isFeatured: {
      type: Boolean,
      default: false,
      index: true,
    },
    
    // Customization options
    customizationOptions: {
      allowDurationAdjustment: Boolean,
      allowEquipmentSubstitution: Boolean,
      allowExerciseSwaps: Boolean,
      allowMacroAdjustment: Boolean,
      minDuration: Number,
      maxDuration: Number,
    },
    
    // Metadata
    metadata: {
      sourceGenerationId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'GeneratedProgram',
      },
      sourceClientProfile: mongoose.Schema.Types.Mixed,
      notes: String,
      internalNotes: String,
    },
  },
  {
    timestamps: true,
  }
);

// Indexes for efficient querying
programTemplateSchema.index({ templateId: 1, version: -1 });
programTemplateSchema.index({ createdBy: 1, isLatestVersion: 1 });
programTemplateSchema.index({ templateType: 1, status: 1 });
programTemplateSchema.index({ category: 1, 'characteristics.experienceLevel': 1 });
programTemplateSchema.index({ tags: 1 });
programTemplateSchema.index({ 'usage.timesUsed': -1 });
programTemplateSchema.index({ 'usage.averageRating': -1 });
programTemplateSchema.index({ visibility: 1, status: 1 });

// Text search index
programTemplateSchema.index({ 
  name: 'text', 
  description: 'text', 
  tags: 'text',
  category: 'text',
});

// Generate templateId before saving
programTemplateSchema.pre('save', function (next) {
  if (!this.templateId) {
    // Generate unique template ID: TPL-{timestamp}-{random}
    const timestamp = Date.now().toString(36);
    const random = crypto.randomBytes(4).toString('hex');
    this.templateId = `TPL-${timestamp}-${random}`;
  }
  next();
});

// Generate fingerprints before saving
programTemplateSchema.pre('save', function (next) {
  if (!this.contentFingerprint) {
    this.contentFingerprint = this.generateContentFingerprint();
  }
  if (!this.inputFingerprint) {
    this.inputFingerprint = this.generateInputFingerprint();
  }
  next();
});

// Methods

/**
 * Generate content fingerprint for duplicate detection
 */
programTemplateSchema.methods.generateContentFingerprint = function () {
  const contentString = JSON.stringify({
    workouts: this.content.workoutProgram?.workouts,
    meals: this.content.nutritionPlan?.meals,
  });
  return crypto.createHash('sha256').update(contentString).digest('hex');
};

/**
 * Generate input fingerprint for caching
 */
programTemplateSchema.methods.generateInputFingerprint = function () {
  const inputString = JSON.stringify({
    type: this.templateType,
    characteristics: this.characteristics,
    goals: this.characteristics?.goals?.sort(),
  });
  return crypto.createHash('sha256').update(inputString).digest('hex');
};

/**
 * Create a new version of this template
 */
programTemplateSchema.methods.createNewVersion = async function (updates, userId) {
  // Mark current version as not latest
  this.isLatestVersion = false;
  await this.save();
  
  // Create new version
  const newVersion = new this.constructor({
    ...this.toObject(),
    _id: undefined,
    templateId: undefined, // Will be auto-generated
    version: this.version + 1,
    isLatestVersion: true,
    parentTemplateId: this.templateId,
    createdBy: userId,
    createdAt: undefined,
    updatedAt: undefined,
    ...updates,
  });
  
  // Add to version history
  newVersion.versionHistory = [
    ...this.versionHistory,
    {
      version: this.version,
      templateId: this.templateId,
      createdAt: this.createdAt,
      createdBy: this.createdBy,
    },
  ];
  
  await newVersion.save();
  return newVersion;
};

/**
 * Increment usage counter
 */
programTemplateSchema.methods.recordUsage = async function () {
  this.usage.timesUsed += 1;
  this.usage.lastUsed = new Date();
  await this.save();
};

/**
 * Add rating
 */
programTemplateSchema.methods.addRating = async function (userId, rating, feedback) {
  this.ratings.push({
    userId,
    rating,
    feedback,
    createdAt: new Date(),
  });
  
  // Recalculate average rating
  const totalRating = this.ratings.reduce((sum, r) => sum + r.rating, 0);
  this.usage.averageRating = totalRating / this.ratings.length;
  
  await this.save();
};

// Statics

/**
 * Find similar templates by fingerprint
 */
programTemplateSchema.statics.findSimilar = async function (fingerprint, limit = 5) {
  return this.find({
    $or: [
      { contentFingerprint: fingerprint },
      { inputFingerprint: fingerprint },
    ],
    status: 'active',
  })
    .limit(limit)
    .sort({ 'usage.averageRating': -1, 'usage.timesUsed': -1 });
};

/**
 * Find by characteristics
 */
programTemplateSchema.statics.findByCharacteristics = async function (characteristics, options = {}) {
  const query = {
    status: 'active',
    isLatestVersion: true,
  };
  
  if (characteristics.experienceLevel) {
    query['characteristics.experienceLevel'] = characteristics.experienceLevel;
  }
  
  if (characteristics.goals && characteristics.goals.length > 0) {
    query['characteristics.goals'] = { $in: characteristics.goals };
  }
  
  if (characteristics.equipment && characteristics.equipment.length > 0) {
    query['characteristics.equipment'] = { $in: characteristics.equipment };
  }
  
  if (characteristics.duration) {
    query['characteristics.duration.weeks'] = characteristics.duration.weeks;
  }
  
  if (options.visibility) {
    query.visibility = { $in: [options.visibility, 'public'] };
  }
  
  return this.find(query)
    .sort({ 'usage.averageRating': -1, 'usage.timesUsed': -1 })
    .limit(options.limit || 20);
};

/**
 * Get latest version of a template
 */
programTemplateSchema.statics.getLatestVersion = async function (parentTemplateId) {
  return this.findOne({
    $or: [
      { templateId: parentTemplateId },
      { parentTemplateId },
    ],
    isLatestVersion: true,
  });
};

/**
 * Get version history
 */
programTemplateSchema.statics.getVersionHistory = async function (templateId) {
  const template = await this.findOne({ templateId });
  if (!template) return [];
  
  const allVersions = await this.find({
    $or: [
      { templateId },
      { parentTemplateId: template.parentTemplateId || templateId },
      { templateId: template.parentTemplateId },
    ],
  }).sort({ version: 1 });
  
  return allVersions;
};

module.exports = mongoose.model('ProgramTemplate', programTemplateSchema);

